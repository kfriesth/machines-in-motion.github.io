<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="coding_guidelines_0" kind="page">
    <compoundname>coding_guidelines_0</compoundname>
    <title>1. General rules applied in the code base</title>
    <detaileddescription>
<para><heading level="2">I. Introduction</heading>
</para><para>These are general rules independent of the coding language.</para><para><heading level="2">II. Catkin Package and Repository Naming</heading>
</para><para><itemizedlist>
<listitem><para>Name: lower_cases_with_underscore.</para></listitem><listitem><para>One repository per catkin package.</para></listitem><listitem><para>Same name for package and repository.</para></listitem></itemizedlist>
</para><para><heading level="2">III. Versioning</heading>
</para><para>Use semantic versioning when versioning packages. Short summary:</para><para><itemizedlist>
<listitem><para>Given a version number MAJOR.MINOR.PATCH, increment the:</para></listitem><listitem><para>MAJOR version when you make incompatible API changes,</para></listitem><listitem><para>MINOR version when you add functionality in a backwards-compatible manner, and</para></listitem><listitem><para>PATCH version when you make backwards-compatible bug fixes.</para></listitem></itemizedlist>
</para><para>Regarding formatting of pre-releases (alpha, beta, rc, ...) consider PEP440, especially when versioning Python packages (note that there is no general conflict with semantic versioning, only the format is a bit different).</para><para><heading level="2">IV. Contribution Guidelines</heading>
</para><para><heading level="3">IV.1. Code revision:</heading>
</para><para>To ensure some level of code quality, all modifications have to be reviewed before they can be merged. This is done via merge requests in GitLab (on GitHub it is called pull request but the concept is the same).</para><para>The procedure for adding a change is as follows:</para><para><itemizedlist>
<listitem><para>When creating branches, use your name as a namespace, e.g. <emphasis>rickdeckard/my_branch</emphasis>. This is to avoid confusion with branches of other people and to indicate who is responsible for that branch. It is not allowed to push branches without such namespace.</para></listitem><listitem><para>Test all your changes and update documentation.</para></listitem><listitem><para>When finished, create a merge request to the master branch of the main repository.</para></listitem><listitem><para>Add one or more of the maintainers as reviewers. The reviewers will review and maybe request changes.</para></listitem><listitem><para>Merging is done by the contributor but is only allowed after all reviewers approved. If the merge will affect other people (e.g. by breaking the API), make sure to inform them, e.g. via a Mail on an appropriate mailing list. After a merge request is merged, the feature branch shall be deleted.</para></listitem></itemizedlist>
</para><para>Never push directly to master or other top-level branches. Never force-push to any branch that others are using as well. All your development should happen in branches inside your namespace. To keep the number of branches on the repository low, make sure to delete branches that are not needed anymore.</para><para>The top-level namespace of the repository should only contain a master branch and maybe a few branches for specific versions. Those branches should be protected so that direct pushing is not possible (everything has to go through merge requests).</para><para><heading level="3">IV.2. Some rules for the contributors:</heading>
</para><para><itemizedlist>
<listitem><para>To make life easier for the reviewers and to get your changes merged quickly (thus reducing the risk of merge conflicts), try to keep merge requests rather small. This means that, where possible, a bigger task should be split into smaller sub-tasks that can be merged one after another instead of putting everything in one huge merge request.</para></listitem><listitem><para>When synchronising your feature branch with upstream, you may want to prefer git rebase over git merge to keep the history of you branch clean. However, when there are complicated merge conflicts, it can be much less painful to use merge, which is okay in this case.</para></listitem><listitem><para>On your own branches, you can do whatever you want, i.e. it is usually okay to force push there (and even necessary when you rebase). However, when applying changes requested by a reviewer, please do not amend or squash them into older commits but add them as new commits. This makes it easier for the reviewer to see what changed.</para></listitem><listitem><para>Do not add functional changes and major reformatting in the same commit as this makes review of the functional changes very difficult.</para></listitem><listitem><para>Do add unit tests for new features</para></listitem><listitem><para>Do create new demos or update existing demos to make it easier how to use the updated API</para></listitem></itemizedlist>
</para><para><heading level="3">IV.3. Some rules for the reviewers:</heading>
</para><para><itemizedlist>
<listitem><para>To make life easier for the contributors, try to provide reviews in a timely manner. The contributor may be blocked in continuing their work while the merge request is under review.</para></listitem><listitem><para>When reviewing, check the following things:<itemizedlist>
<listitem><para>Is the style guide followed?</para></listitem><listitem><para>Are new features/changes properly documented?</para></listitem><listitem><para>And of course: Do the changes look reasonable and correct?</para></listitem></itemizedlist>
</para></listitem><listitem><para>The one who merges should directly delete the feature branch afterwards.</para></listitem></itemizedlist>
</para><para><heading level="2">V. Documentation</heading>
</para><para><heading level="3">V.1 In-code documentation</heading>
</para><para>All code <bold>shall</bold> be documented in-source using Doxygen. This means that every function, class, struct, global variable, etc, needs to have a docstring containing some documentation in:<itemizedlist>
<listitem><para><ulink url="https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments">Google</ulink> format for Python,</para></listitem><listitem><para><ulink url="http://www.doxygen.nl/manual/index.html">Doxygen</ulink> format for C/C++.</para></listitem></itemizedlist>
</para><para>If the definition and declaration are separated (C/C++), Doxygen should be in the header, not the cpp file. <bold>Please do not duplicate!</bold>.</para><para>If you are using catkin, the package should include the mpi_cmake_modules package and in the CMakeLists.txt file call the <computeroutput>build_doxygen_documentation()</computeroutput> or the <computeroutput>default_mpi_cmake_modules()</computeroutput>(future) macros. The documentation can then be build via catkin_make -DBUILD_DOCUMENTATION=ON.</para><para>Make the documentation as compact as possible. Avoid boilerplate formulations that do not add useful information, e.g. instead of &quot;This function returns foobar&quot; simply write &quot;Returns foobar&quot;.</para><para>Also add regular comments to the code whenever you feel that they would help a future reader to more easily understand what that code is doing.</para><para><heading level="3">V.2 Unit-tests and demos</heading>
</para><para>Please do <bold>NOT</bold> neglect the power of the continuous intergation and a nice written demos in terms of Documentation. So <bold>please</bold> take the time to:<itemizedlist>
<listitem><para>write some unit-tests. See how to write a unit-tests from the tests folder in this package.</para></listitem><listitem><para>write demo executables to make the external user understand how your API should be used. </para></listitem></itemizedlist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
