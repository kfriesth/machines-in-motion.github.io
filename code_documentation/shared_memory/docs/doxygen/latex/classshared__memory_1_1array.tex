\hypertarget{classshared__memory_1_1array}{}\section{shared\+\_\+memory\+:\+:array$<$ T, S\+I\+ZE $>$ Class Template Reference}
\label{classshared__memory_1_1array}\index{shared\+\_\+memory\+::array$<$ T, S\+I\+Z\+E $>$@{shared\+\_\+memory\+::array$<$ T, S\+I\+Z\+E $>$}}


Implement a shared array stored on a shared memory segment.  




{\ttfamily \#include $<$array.\+hpp$>$}



Inheritance diagram for shared\+\_\+memory\+:\+:array$<$ T, S\+I\+ZE $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=223pt]{classshared__memory_1_1array__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for shared\+\_\+memory\+:\+:array$<$ T, S\+I\+ZE $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classshared__memory_1_1array__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1array_a95b5abd158cb04ab0644f5aa6df48b2b}{array} (std\+::string segment\+\_\+id, std\+::size\+\_\+t \hyperlink{classshared__memory_1_1array_ad6019f83449e4ea8d1bf4bd0d48c29b0}{size}, bool clear\+\_\+on\+\_\+destruction=true, bool multiprocess\+\_\+safe=true)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a45cad350fdb0170c955c8c367a9e910d}\label{classshared__memory_1_1array_a45cad350fdb0170c955c8c367a9e910d}} 
\hyperlink{classshared__memory_1_1array_a45cad350fdb0170c955c8c367a9e910d}{$\sim$array} ()
\begin{DoxyCompactList}\small\item\em wipe the related shared memory segment if clear\+\_\+on\+\_\+destruction is true (true by default) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_acde1531706ba2ab6c05d7639bc0f6f56}\label{classshared__memory_1_1array_acde1531706ba2ab6c05d7639bc0f6f56}} 
\hyperlink{classshared__memory_1_1array_acde1531706ba2ab6c05d7639bc0f6f56}{array} (const \hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \&other)
\begin{DoxyCompactList}\small\item\em this array and other array will point to the same memory segment, and will have same values for clear\+\_\+on\+\_\+destruction and multiprocess\+\_\+safe \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1array_af399f2f20d16dadf8381c61ea5ad42fd}{array} (\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em This array will point to the share memory segment pointed at by other; and will have same value for multprocess\+\_\+safe and clear\+\_\+on\+\_\+destruction. \end{DoxyCompactList}\item 
\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \& \hyperlink{classshared__memory_1_1array_ad5b4b2841b2785b188a6371cb7f00f1f}{operator=} (\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \&\&other) noexcept
\begin{DoxyCompactList}\small\item\em This array will point to the share memory segment pointed at by other; and will have same value for multprocess\+\_\+safe and clear\+\_\+on\+\_\+destruction. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ac413bc76d199bb52a0f95faff7222f37}\label{classshared__memory_1_1array_ac413bc76d199bb52a0f95faff7222f37}} 
void \hyperlink{classshared__memory_1_1array_ac413bc76d199bb52a0f95faff7222f37}{set} (uint index, const T \&t)
\begin{DoxyCompactList}\small\item\em set element t at index \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ae581f4ffcf1e543032e0128be5da181d}\label{classshared__memory_1_1array_ae581f4ffcf1e543032e0128be5da181d}} 
void \hyperlink{classshared__memory_1_1array_ae581f4ffcf1e543032e0128be5da181d}{set} (uint index, const T $\ast$t)
\begin{DoxyCompactList}\small\item\em set element t at index \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ae16ed72c9590631e608de8bacf1368ba}\label{classshared__memory_1_1array_ae16ed72c9590631e608de8bacf1368ba}} 
void \hyperlink{classshared__memory_1_1array_ae16ed72c9590631e608de8bacf1368ba}{get} (uint index, T \&t)
\begin{DoxyCompactList}\small\item\em read element at index into t \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ad700d5874d92def07f77f4da7f31f980}\label{classshared__memory_1_1array_ad700d5874d92def07f77f4da7f31f980}} 
void \hyperlink{classshared__memory_1_1array_ad700d5874d92def07f77f4da7f31f980}{get} (uint index, T $\ast$t)
\begin{DoxyCompactList}\small\item\em read element at index into t \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ad6019f83449e4ea8d1bf4bd0d48c29b0}\label{classshared__memory_1_1array_ad6019f83449e4ea8d1bf4bd0d48c29b0}} 
std\+::size\+\_\+t \hyperlink{classshared__memory_1_1array_ad6019f83449e4ea8d1bf4bd0d48c29b0}{size} () const
\begin{DoxyCompactList}\small\item\em max number of elements in the array \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a9e912e143886359921c04fdbba7f6cba}\label{classshared__memory_1_1array_a9e912e143886359921c04fdbba7f6cba}} 
void \hyperlink{classshared__memory_1_1array_a9e912e143886359921c04fdbba7f6cba}{print} ()
\begin{DoxyCompactList}\small\item\em print in terminal info about array\textquotesingle{}s memory usage \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a20e27fb6b9a18e252368c4f6118b3d27}\label{classshared__memory_1_1array_a20e27fb6b9a18e252368c4f6118b3d27}} 
void $\ast$ {\bfseries get\+\_\+raw} ()
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a41258d788855ccc8435efb2017bdd068}\label{classshared__memory_1_1array_a41258d788855ccc8435efb2017bdd068}} 
void {\bfseries init} (F\+U\+N\+D\+A\+M\+E\+N\+T\+AL)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ad7fa6301507f10efe97ce3ad40187d9f}\label{classshared__memory_1_1array_ad7fa6301507f10efe97ce3ad40187d9f}} 
void {\bfseries set} (uint index, const T \&t, F\+U\+N\+D\+A\+M\+E\+N\+T\+AL)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a0a54a689331205da7338f7c5891a6ee5}\label{classshared__memory_1_1array_a0a54a689331205da7338f7c5891a6ee5}} 
void {\bfseries get} (uint index, T \&t, F\+U\+N\+D\+A\+M\+E\+N\+T\+AL)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_ac0e57adf8e47afae3f8053c20c3e15f2}\label{classshared__memory_1_1array_ac0e57adf8e47afae3f8053c20c3e15f2}} 
void {\bfseries init} (F\+U\+N\+D\+A\+M\+E\+N\+T\+A\+L\+\_\+\+A\+R\+R\+AY)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a71bbc60da4a88fd51b3124cdb6cd1ae3}\label{classshared__memory_1_1array_a71bbc60da4a88fd51b3124cdb6cd1ae3}} 
void {\bfseries set} (uint index, const T \&t, F\+U\+N\+D\+A\+M\+E\+N\+T\+A\+L\+\_\+\+A\+R\+R\+AY)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_af12c8f76fc48b3ec1ff2c2c82d104837}\label{classshared__memory_1_1array_af12c8f76fc48b3ec1ff2c2c82d104837}} 
void {\bfseries get} (uint index, T \&t, F\+U\+N\+D\+A\+M\+E\+N\+T\+A\+L\+\_\+\+A\+R\+R\+AY)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a487be484bf27d17f8c7547a57ff995f9}\label{classshared__memory_1_1array_a487be484bf27d17f8c7547a57ff995f9}} 
void {\bfseries init} (S\+E\+R\+I\+A\+L\+I\+Z\+A\+B\+LE)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a951c9ca373e942f094910bea57953eb0}\label{classshared__memory_1_1array_a951c9ca373e942f094910bea57953eb0}} 
void {\bfseries set} (uint index, const T \&t, S\+E\+R\+I\+A\+L\+I\+Z\+A\+B\+LE)
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_afb0025021b69b790c152c27ef441cd66}\label{classshared__memory_1_1array_afb0025021b69b790c152c27ef441cd66}} 
void {\bfseries get} (uint index, T \&t, S\+E\+R\+I\+A\+L\+I\+Z\+A\+B\+LE)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a43c56477481ae684932b6a03b64d7b67}\label{classshared__memory_1_1array_a43c56477481ae684932b6a03b64d7b67}} 
boost\+::interprocess\+::managed\+\_\+shared\+\_\+memory {\bfseries segment\+\_\+manager\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a25a07e97c454f8fb122eb092ab29812c}\label{classshared__memory_1_1array_a25a07e97c454f8fb122eb092ab29812c}} 
std\+::string {\bfseries segment\+\_\+id\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a1b47b48a2779e766a80403f47404876a}\label{classshared__memory_1_1array_a1b47b48a2779e766a80403f47404876a}} 
std\+::size\+\_\+t {\bfseries size\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_afb6fcb395ac52cb9eaaef2882b623d23}\label{classshared__memory_1_1array_afb6fcb395ac52cb9eaaef2882b623d23}} 
bool {\bfseries clear\+\_\+on\+\_\+destruction\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_a7051346ccb28372b2ea5587714113079}\label{classshared__memory_1_1array_a7051346ccb28372b2ea5587714113079}} 
bool {\bfseries multiprocess\+\_\+safe\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1array_afaf6604cf5e2c380f86679e1515e6674}\label{classshared__memory_1_1array_afaf6604cf5e2c380f86679e1515e6674}} 
\hyperlink{classshared__memory_1_1Mutex}{shared\+\_\+memory\+::\+Mutex} {\bfseries mutex\+\_\+}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T, int S\+I\+ZE = 0$>$\newline
class shared\+\_\+memory\+::array$<$ T, S\+I\+Z\+E $>$}

Implement a shared array stored on a shared memory segment. 

Items hosted by the array may be of (1) fundamental type (e.\+g. int, double, char), (2) array of fundamental type (e.\+g. int\mbox{[}10\mbox{]}); or (3) instances of a class implementing a serializable function (see shared\+\_\+memory\+::serializer). 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classshared__memory_1_1array_a95b5abd158cb04ab0644f5aa6df48b2b}\label{classshared__memory_1_1array_a95b5abd158cb04ab0644f5aa6df48b2b}} 
\index{shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}!array@{array}}
\index{array@{array}!shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}}
\subsubsection{\texorpdfstring{array()}{array()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , int S\+I\+ZE$>$ \\
\hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}$<$ T, S\+I\+ZE $>$\+::\hyperlink{classshared__memory_1_1array}{array} (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id,  }\item[{std\+::size\+\_\+t}]{size,  }\item[{bool}]{clear\+\_\+on\+\_\+destruction = {\ttfamily true},  }\item[{bool}]{multiprocess\+\_\+safe = {\ttfamily true} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & should be the same for all array pointing to the same shared memory segment \\
\hline
{\em size} & \+: number of elements to be stored by the array \\
\hline
{\em clear\+\_\+on\+\_\+destruction} & if true, the shared memory segment will be wiped on destruction of the array. Note that any other array pointing to this segment may hang indefinitely as a result. If no arrays pointing to the shared memory segment delete the segment, then users are expected to call \hyperlink{namespaceshared__memory_a0371eb6089f446098adf2f9c106333dc}{shared\+\_\+memory\+::clear\+\_\+array}. Failing to do so may result in new array pointing to a new memory segment of the same id to hang indefinitely at construction. \\
\hline
{\em multiprocess\+\_\+safe} & if false, it is strongly adviced to protect accesses via a \hyperlink{classshared__memory_1_1Mutex}{shared\+\_\+memory\+::\+Mutex} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classshared__memory_1_1array_af399f2f20d16dadf8381c61ea5ad42fd}\label{classshared__memory_1_1array_af399f2f20d16dadf8381c61ea5ad42fd}} 
\index{shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}!array@{array}}
\index{array@{array}!shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}}
\subsubsection{\texorpdfstring{array()}{array()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , int S\+I\+ZE$>$ \\
\hyperlink{classshared__memory_1_1array}{shared\+\_\+memory\+::array}$<$ T, S\+I\+ZE $>$\+::\hyperlink{classshared__memory_1_1array}{array} (\begin{DoxyParamCaption}\item[{\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



This array will point to the share memory segment pointed at by other; and will have same value for multprocess\+\_\+safe and clear\+\_\+on\+\_\+destruction. 

Warning\+: even if other.\+clear\+\_\+on\+\_\+destruction is true, the segment memory will not be wiped on the destruction of other. The duty of deleting the shared memory is passed to the new instance, so to speak 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classshared__memory_1_1array_ad5b4b2841b2785b188a6371cb7f00f1f}\label{classshared__memory_1_1array_ad5b4b2841b2785b188a6371cb7f00f1f}} 
\index{shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}!operator=@{operator=}}
\index{operator=@{operator=}!shared\+\_\+memory\+::array@{shared\+\_\+memory\+::array}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily template$<$typename T , int S\+I\+ZE$>$ \\
\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \& array\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{classshared__memory_1_1array}{array}$<$ T, S\+I\+ZE $>$ \&\&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



This array will point to the share memory segment pointed at by other; and will have same value for multprocess\+\_\+safe and clear\+\_\+on\+\_\+destruction. 

Warning\+: even if other.\+clear\+\_\+on\+\_\+destruction is true, the segment memory will not be wiped on the destruction of other. The duty of deleting the shared memory is passed to the new instance, so to speak 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/array.\+hpp\item 
include/shared\+\_\+memory/array.\+hxx\item 
include/shared\+\_\+memory/array\+\_\+fundamental.\+hxx\item 
include/shared\+\_\+memory/array\+\_\+fundamental\+\_\+array.\+hxx\item 
include/shared\+\_\+memory/array\+\_\+serializable.\+hxx\end{DoxyCompactItemize}
