\hypertarget{classshared__memory_1_1Exchange__manager__producer}{}\section{shared\+\_\+memory\+:\+:Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ Class Template Reference}
\label{classshared__memory_1_1Exchange__manager__producer}\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer$<$ Serializable, Q\+U\+E\+U\+E\+\_\+\+S\+I\+Z\+E $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}{Exchange\+\_\+manager\+\_\+producer} (std\+::string segment\+\_\+id, std\+::string object\+\_\+id, bool leading, bool autolock=true)
\begin{DoxyCompactList}\small\item\em An exchange\+\_\+manager\+\_\+producer writes in the shared memory serialized items expected to be consumed by an instance of exchange\+\_\+manager\+\_\+consumer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}{ready\+\_\+to\+\_\+produce} ()
\begin{DoxyCompactList}\small\item\em returns true if a consumer is also running. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}{lock} ()
\begin{DoxyCompactList}\small\item\em lock the mutex required for writting in the shared memory without any collision with any consumer. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}{unlock} ()
\begin{DoxyCompactList}\small\item\em unlock the mutex for writting in the shared memory without any collision with any consumer. \end{DoxyCompactList}\item 
bool \hyperlink{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}{set} (const \hyperlink{classSerializable}{Serializable} \&serializable)
\begin{DoxyCompactList}\small\item\em Set this serializable to be consumed. \end{DoxyCompactList}\item 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}{clear} ()
\begin{DoxyCompactList}\small\item\em removed all elements from the shared queue \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}\label{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}} 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_afd8afb25d70407b785484e68d1182c0b}{get} (std\+::deque$<$ int $>$ \&get\+\_\+consumed\+\_\+ids)
\begin{DoxyCompactList}\small\item\em write into get\+\_\+consumed\+\_\+ids the ids of serialized items that have been successfully consumed by a consumer \end{DoxyCompactList}\item 
int \hyperlink{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}{nb\+\_\+char\+\_\+written} ()
\begin{DoxyCompactList}\small\item\em returns the number of characters that have been serialized and written to the exchange queue. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}\label{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}} 
void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a742e8859608d49901d3dafbbe08e4674}{reset\+\_\+char\+\_\+count} ()
\begin{DoxyCompactList}\small\item\em reset the count of characters written to the exchange queue to zero \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a4a38c8c14004bc46d254375a63f62096}\label{classshared__memory_1_1Exchange__manager__producer_a4a38c8c14004bc46d254375a63f62096}} 
bool {\bfseries producer\+\_\+queue\+\_\+empty} () const
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_ab8f5eef0601cfdb418eb5d521bfa33d0}\label{classshared__memory_1_1Exchange__manager__producer_ab8f5eef0601cfdb418eb5d521bfa33d0}} 
bool {\bfseries consumer\+\_\+queue\+\_\+empty} () const
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}{clean\+\_\+mutex} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em (unlock) and erase the mutex from the shared memory. \end{DoxyCompactList}\item 
static void \hyperlink{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}{clean\+\_\+memory} (std\+::string segment\+\_\+id)
\begin{DoxyCompactList}\small\item\em wipe out the corresponding shared memory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a65119cf07c0c10f167c191c9ee913029}\label{classshared__memory_1_1Exchange__manager__producer_a65119cf07c0c10f167c191c9ee913029}} 
typedef Exchange\+\_\+manager\+\_\+memory$<$ \hyperlink{classSerializable}{Serializable}, Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE $>$ {\bfseries Memory}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a7f3d7760ca2d1c01fa88e7a6447a38d7}\label{classshared__memory_1_1Exchange__manager__producer_a7f3d7760ca2d1c01fa88e7a6447a38d7}} 
typedef std\+::shared\+\_\+ptr$<$ Memory $>$ {\bfseries Memory\+\_\+ptr}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a2148cfb2e9a1973089d81237ea5735b9}\label{classshared__memory_1_1Exchange__manager__producer_a2148cfb2e9a1973089d81237ea5735b9}} 
void {\bfseries reset} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a67f2a2c049dabace06c85a35335d1614}\label{classshared__memory_1_1Exchange__manager__producer_a67f2a2c049dabace06c85a35335d1614}} 
Memory\+\_\+ptr {\bfseries memory\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a6d89b939f08bbb9180460a0fab2c877f}\label{classshared__memory_1_1Exchange__manager__producer_a6d89b939f08bbb9180460a0fab2c877f}} 
bool {\bfseries autolock\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a4c71d725b7b95e4dd00ecf68232d4ac9}\label{classshared__memory_1_1Exchange__manager__producer_a4c71d725b7b95e4dd00ecf68232d4ac9}} 
bool {\bfseries leading\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a96ce58e9619ac28b31b46a81c53c20c2}\label{classshared__memory_1_1Exchange__manager__producer_a96ce58e9619ac28b31b46a81c53c20c2}} 
std\+::string {\bfseries segment\+\_\+id\+\_\+}
\item 
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a57ea2e6076963223331f3b6e78cbbc05}\label{classshared__memory_1_1Exchange__manager__producer_a57ea2e6076963223331f3b6e78cbbc05}} 
std\+::string {\bfseries object\+\_\+id\+\_\+}
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}\label{classshared__memory_1_1Exchange__manager__producer_a3fb01ae44f85b9d8b4a22137f2da90f1}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!Exchange\+\_\+manager\+\_\+producer@{Exchange\+\_\+manager\+\_\+producer}}
\index{Exchange\+\_\+manager\+\_\+producer@{Exchange\+\_\+manager\+\_\+producer}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{Exchange\+\_\+manager\+\_\+producer()}{Exchange\_manager\_producer()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
Exchange\+\_\+manager\+\_\+producer\+::\+Exchange\+\_\+manager\+\_\+producer (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id,  }\item[{std\+::string}]{object\+\_\+id,  }\item[{bool}]{leading,  }\item[{bool}]{autolock = {\ttfamily true} }\end{DoxyParamCaption})}



An exchange\+\_\+manager\+\_\+producer writes in the shared memory serialized items expected to be consumed by an instance of exchange\+\_\+manager\+\_\+consumer (which should use the same segment\+\_\+id and object\+\_\+id), possibly running in a separate process. 


\begin{DoxyParams}{Parameters}
{\em segment\+\_\+id} & id of the shared memory segment \\
\hline
{\em object\+\_\+id} & id of the shared memory object prefix \\
\hline
{\em autolock} & mutex locking mechanism internally managed by the producer. If false, lock has to be \char`\"{}manually\char`\"{} called. This allows for example to set several items in one shot \\
\hline
{\em clean\+\_\+memory\+\_\+on\+\_\+exit.} & If true, the destructor will clean the underlined shared memory items. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}\label{classshared__memory_1_1Exchange__manager__producer_a8574f4e075d6f755e567d21d04f24aab}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clean\+\_\+memory@{clean\+\_\+memory}}
\index{clean\+\_\+memory@{clean\+\_\+memory}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{clean\+\_\+memory()}{clean\_memory()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+producer\+::clean\+\_\+memory (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



wipe out the corresponding shared memory. 

To be used if some executable using the exchange manager crashed without calls to destructors. \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}\label{classshared__memory_1_1Exchange__manager__producer_af98fe4321e1fd280b509f5dfd2cf4a5b}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clean\+\_\+mutex@{clean\+\_\+mutex}}
\index{clean\+\_\+mutex@{clean\+\_\+mutex}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{clean\+\_\+mutex()}{clean\_mutex()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+producer\+::clean\+\_\+mutex (\begin{DoxyParamCaption}\item[{std\+::string}]{segment\+\_\+id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



(unlock) and erase the mutex from the shared memory. 

To be used if some executable using the exchange manager crashed without calls to destructors. \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}\label{classshared__memory_1_1Exchange__manager__producer_a733c4c3f794e10590569f94e3f320201}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!clear@{clear}}
\index{clear@{clear}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+producer\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



removed all elements from the shared queue 

\mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}\label{classshared__memory_1_1Exchange__manager__producer_aa39c8b921eeff081111c756bd6d2ca3d}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!lock@{lock}}
\index{lock@{lock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{lock()}{lock()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+producer\+::lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



lock the mutex required for writting in the shared memory without any collision with any consumer. 

Should be called before calls to \char`\"{}set\char`\"{}. Not required if the constructor was called with autolock set to true \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}\label{classshared__memory_1_1Exchange__manager__producer_ab31e6b87ad4c856736dec15486ed4489}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!nb\+\_\+char\+\_\+written@{nb\+\_\+char\+\_\+written}}
\index{nb\+\_\+char\+\_\+written@{nb\+\_\+char\+\_\+written}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{nb\+\_\+char\+\_\+written()}{nb\_char\_written()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
int Exchange\+\_\+manager\+\_\+producer\+::nb\+\_\+char\+\_\+written (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



returns the number of characters that have been serialized and written to the exchange queue. 

For debug purposes. \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}\label{classshared__memory_1_1Exchange__manager__producer_a3ef5cfdd196a396edfd6ca502119f839}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!ready\+\_\+to\+\_\+produce@{ready\+\_\+to\+\_\+produce}}
\index{ready\+\_\+to\+\_\+produce@{ready\+\_\+to\+\_\+produce}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{ready\+\_\+to\+\_\+produce()}{ready\_to\_produce()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
bool Exchange\+\_\+manager\+\_\+producer\+::ready\+\_\+to\+\_\+produce (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



returns true if a consumer is also running. 

\textquotesingle{}set\textquotesingle{} should be called only if ready\+\_\+to\+\_\+produce returns true. \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}\label{classshared__memory_1_1Exchange__manager__producer_a0f86798dbbb5bead856c566257bd1b07}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!set@{set}}
\index{set@{set}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{set()}{set()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
bool Exchange\+\_\+manager\+\_\+producer\+::set (\begin{DoxyParamCaption}\item[{const \hyperlink{classSerializable}{Serializable} \&}]{serializable }\end{DoxyParamCaption})}



Set this serializable to be consumed. 

Throws \hyperlink{classshared__memory_1_1Memory__overflow__exception}{shared\+\_\+memory\+::\+Memory\+\_\+overflow\+\_\+exception} if the shared memory is full. Some of the shared memory should get free once items have been consumed by a consumer. This method should be called only if \textquotesingle{}ready\+\_\+to\+\_\+produce\textquotesingle{} returns true; Returns true if all data could be written in the shared memory, false if some data required to be buffered (any following call to set, if any, will perform a new attempt to write remaining buffer to the shared memory) \mbox{\Hypertarget{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}\label{classshared__memory_1_1Exchange__manager__producer_a9c02040ee5ef8db658f3112ae4b3b969}} 
\index{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}!unlock@{unlock}}
\index{unlock@{unlock}!shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer@{shared\+\_\+memory\+::\+Exchange\+\_\+manager\+\_\+producer}}
\subsubsection{\texorpdfstring{unlock()}{unlock()}}
{\footnotesize\ttfamily template$<$class Serializable , int Q\+U\+E\+U\+E\+\_\+\+S\+I\+ZE$>$ \\
void Exchange\+\_\+manager\+\_\+producer\+::unlock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



unlock the mutex for writting in the shared memory without any collision with any consumer. 

Not required if the constructor was called with autolock set to true 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/shared\+\_\+memory/\hyperlink{exchange__manager__producer_8hpp}{exchange\+\_\+manager\+\_\+producer.\+hpp}\item 
include/shared\+\_\+memory/exchange\+\_\+manager\+\_\+producer.\+hxx\end{DoxyCompactItemize}
